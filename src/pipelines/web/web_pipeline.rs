use std::path::PathBuf;

use notify::{RecommendedWatcher, RecursiveMode, Watcher};

use crate::*;
use path_absolutize::Absolutize;

pub const WEB_FEATURE: &str = "web";
pub const WEB_TARGET: &str = "wasm32-unknown-unknown";

/// web pipeline using wasm
pub struct WebPipeline<'a> {
    args: &'a mut Args,
    #[allow(dead_code)]
    cargo_toml: &'a mut CargoToml,
    /// path to hashed wasm file in --out-dir
    hashed_wasm_name: String,
}

impl<'a> WebPipeline<'a> {
    /// builds and generates Self struct
    pub async fn new(args: &'a mut Args, cargo_toml: &'a mut CargoToml) -> Result<WebPipeline<'a>> {
        // write web feature
        {
            cargo_toml.add_features(vec![WEB_FEATURE.to_string()]);
            cargo_toml.write_to_file().await?;
        }
        // init args
        {
            let web_args = args.subcmd.as_web_mut()?;
            // make target dir absolute
            web_args.target_dir = Path::new(&web_args.target_dir)
                .absolutize()
                .with_context(|| format!("error getting absolute path for --target-dir {}", web_args.target_dir))?
                .to_str().unwrap().to_string();
            // make output dir absolute
            web_args.output_dir = Path::new(&web_args.output_dir)
                .absolutize()
                .with_context(|| format!("error getting absolute path for --output-dir {}", web_args.output_dir))?
                .to_str().unwrap().to_string();
        }
        let mut this = Self {
            args,
            cargo_toml,
            //make dummy wasm_hashed_name
            hashed_wasm_name: String::new(),
        };
        // build to make valid hashed_wasm_name
        this.build().await?;
        this.hashed_wasm_name = this.generate_hashed_wasm_name().await?;
        Ok(this)
    }

    /// runs commands according to args
    pub async fn run(&mut self) -> Result<()> {
        println!("building web");
        // check args
        {
            let web_args = self.args.subcmd.as_web()?;
            if web_args.serve {
                self.watch().await?;
            }
            // run wasm bindgen
            self.build_bindings().await?;
            if self.args.subcmd.as_web()?.release {
                self.optimise_build().await?;
            }
        }
        Ok(())
    }

    pub async fn optimise_build(&self) -> Result<()> {
        let web_subcmd = self.args.subcmd.as_web()?;
        let file_name = self.hashed_wasm_name.as_str();
        exec_cmd(
            "wasm-opt",
            &["-Oz", file_name, "-o", file_name],
            Some(&web_subcmd.output_dir),
            None,
        ).await?;
        Ok(())
    }

    /// generates path .wasm file generated by cargo build
    pub fn generate_path_to_target_wasm(&self) -> Result<PathBuf> {
        let web_subcmd = self.args.subcmd.as_web()?;
        Ok(Path::new(&web_subcmd.target_dir)
            .join(WEB_TARGET)
            .join(if web_subcmd.release {
                "release"
            } else {
                "debug"
            })
            // TODO: Get project name
            .join("web.wasm")
            .canonicalize()?)
    }

    /// generates hash_named for output wasm file generated by cargo build
    /// default : target/wasm32-unknown-unknown/{release/debug}/<name>.wasm
    /// default-name : index-<hash>.wasm
    pub async fn generate_hashed_wasm_name(&self) -> Result<String> {
        Ok(format!("index-{}.wasm", get_file_hash(self.generate_path_to_target_wasm()?).await?))
    }

    /// run cargo build
    pub async fn build(&self) -> Result<()> {
        let web_subcmd = self.args.subcmd.as_web()?;
        let mut args = vec![
            "build",
            "--target",
            WEB_TARGET,
            "--target-dir",
            &web_subcmd.target_dir,
        ];
        if web_subcmd.release {
            args.push("--release")
        }
        exec_cmd("cargo", &args, Some(&self.args.dir), None)
            .await
            .with_context(|| format!("error running cargo to build for web"))?;
        Ok(())
    }

    /// rust wasm-bindgen on the target binary
    pub async fn build_bindings(&self) -> Result<()> {
        let web_subcmd = self.args.subcmd.as_web()?;
        exec_cmd(
            "wasm-bindgen",
            &vec![
                self.generate_path_to_target_wasm().unwrap().to_str().unwrap(),
                // build for web
                "--target",
                "web",
                // no type script
                "--no-typescript",
                // dir to place the assets at
                "--out-dir",
                &web_subcmd.output_dir,
                // name of output file
                "--out-name",
                self.hashed_wasm_name.as_str()
            ],
            Option::<&str>::None,
            None,
        )
            .await
            .with_context(|| format!("error running cargo-bindgen on "))?;
        Ok(())
    }

    pub async fn watch(&self) -> Result<()> {
        let mut watcher: RecommendedWatcher = Watcher::new_immediate(|res| match res {
            Ok(event) => println!("event: {:?}", event),
            Err(e) => println!("watch error: {:?}", e),
        })
            .with_context(|| "Error initialising watcher")?;

        watcher
            .watch(format!("{}/src", self.args.dir), RecursiveMode::Recursive)
            .with_context(|| format!("error watching {}/src", self.args.dir))?;
        Ok(())
    }
}
